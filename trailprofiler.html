<!DOCTYPE html>

<head>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/chartist.js/latest/chartist.min.css">
    <script src="https://cdn.jsdelivr.net/chartist.js/latest/chartist.min.js"></script>
    <style>
        body{
            padding: 20px;
            font-family:arial;
        }
        #chart1{
            padding-top:20px;
            border: 1px solid silver;
            border-radius: 10px;
            background-color: lightyellow;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="chart1" class="ct-chart" ><strong>Elevation Profile</strong></div>
    <div id="app">
        <div class="container m-5 table-responsive-sm">
            <h1>Trail Data</h1>
            <form id="file-input-form">
                <p>
                    <label for="my-file" class="btn btn-primary">Add GPX file(s)</label>
                    <input id="my-file" style="visibility:hidden;" class="m-3" name="files[]" accept=".gpx" multiple type="file" />
                </p>
            </form>
            <table class="table table-sm table-hover">
                <thead>
                    <tr>
                        <th scope="col">Date</th>
                        <th scope="col">Name</th>
                        <th scope="col">Actions</th>
                        <th scope="col">Points</th>
                        <th scope="col">Time (sec)</th>
                        <th scope="col">Distance (mi)</th>
                        <th scope="col">Min Elev. (m)</th>
                        <th scope="col">Max Elev. (m)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-for="(sequence,index) in sequences">
                        <td scope="row">{{ sequence.points[0].time | to_datestring }}</td>
                        <th>{{ sequence.name }}</th>
                        <td>
                            <button class="btn btn-xs btn-primary" v-on:click="plotSequence(index)">p</button>
                            <button class="btn btn-xs btn-primary" v-on:click="deleteSequence(index)">d</button>
                        </td>
                        <td>{{ sequence.points.length }}</td>
                        <td>{{ sequence.total_time }}</td>
                        <td>{{ sequence.total_distance }}</td>
                        <td>{{ sequence.minimum_elevation }}</td>
                        <td>{{ sequence.maximum_elevation }}</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</body>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<script>

let vm = new Vue({
    el: '#app',
    data: {
        sequences: []
    },
    mounted() {
        if (localStorage.sequences) {
            this.sequences = JSON.parse(localStorage.sequences);
        }
    },
    watch: {
        sequences: {
            handler: function (new_sequences) {
                localStorage.sequences = JSON.stringify(new_sequences);
            },
            deep: true
        }
    },
    filters: {
        to_datestring: function (epoch) {
            if (!epoch) return ''
            converted = new Date(epoch);
            return converted.toDateString();
        }
    },
    methods: {
        plotSequence: function (sequence_num) {
            chart.update(getChartDataFromSequence(this.sequences[sequence_num]));
        },
        deleteSequence: function (sequence_num) {
            this.sequences.splice(sequence_num, 1);
        }
    }
});

let chart = new Chartist.Line('#chart1', 
    {
        labels: ['0mi', '1mi', '2mi', '3mi', '4mi'],
        series: [
            [12, 9, 7, 8, 5],
            [2, 1, 3.5, 7, 3],
            [1, 3, 4, 5, 6]
        ]
    }, {
        height: '400px',
        fullWidth: true,
        chartPadding: {
            right: 40
        },
        axisX: {
            labelInterpolationFnc: function skipLabels(value, index) {
                return index % 150 === 0 ? Math.round(10*value)/10 : null;
            }
        }
    }
);

function getDeltaDistanceInMiles(lat1, lon1, lat2, lon2) {
    var R = 3956; // Radius of the earth in miles
    var dLat = deg2rad(lat2-lat1);  // deg2rad below
    var dLon = deg2rad(lon2-lon1); 
    var a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
        Math.sin(dLon/2) * Math.sin(dLon/2); 
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
    var d = R * c; // Distance in miles
    return d;
}

function deg2rad(deg) {
    return deg * (Math.PI/180)
}

function addGpxData(gpx_xml) {

    let parser, xml_doc;
    let new_sequence = {};

    if (window.DOMParser)
    {
        parser = new DOMParser();
        xml_doc = parser.parseFromString(gpx_xml, "text/xml");
    }
    else // Internet Explorer
    {
        xml_doc = new ActiveXObject("Microsoft.XMLDOM");
        xml_doc.async = false;
        xml_doc.loadXML(gpx_xml);
    }

    new_sequence["name"] = xml_doc.getElementsByTagName("name")[0].innerHTML;
    for (sequence of vm.sequences) {
        if (sequence.name === new_sequence.name) {
            return; // don't add duplicates
        }
    }
    new_sequence["points"] = [];
    let points = xml_doc.getElementsByTagName("trkpt");
    let prev_lat, prev_long, total_distance = 0;
    let prev_time, total_time = 0;
    let min_ele, max_ele = 0;
    for (p of points) {
        let new_time = new Date(p.getElementsByTagName("time")[0].innerHTML).valueOf();
        let new_point = {
            "time": new_time,
            "latitude": p.getAttribute("lat"),
            "longitude": p.getAttribute("lon"),
            "elevation": parseInt(p.getElementsByTagName("ele")[0].innerHTML)
        };
        if (new_sequence.points.length > 0) {
            total_distance += getDeltaDistanceInMiles(prev_lat, prev_lon, new_point.latitude, new_point.longitude);
            new_point["agg_distance"] = total_distance;
            total_time += new_point.time - prev_time;
            new_point["agg_time"] = total_time/1000;
            max_ele = (new_point.elevation > max_ele) ? new_point.elevation : max_ele;
            min_ele = (new_point.elevation < min_ele) ? new_point.elevation : min_ele;
        } else {
            new_point["agg_distance"] = 0;
            new_point["agg_time"] = 0;
            max_ele = new_point.elevation;
            min_ele = new_point.elevation;
        }
        prev_lat = new_point.latitude;
        prev_lon = new_point.longitude;
        prev_time = new_point.time;

        new_sequence.points.push(new_point);
    }

    new_sequence["total_distance"] = total_distance;
    new_sequence["total_time"] = total_time/1000;
    new_sequence["maximum_elevation"] = max_ele;
    new_sequence["minimum_elevation"] = min_ele;

    vm.sequences.push(new_sequence);
    new_chart_data = getChartDataFromSequence(new_sequence);
    chart.update(new_chart_data);
}

function getChartDataFromSequence(sequence) {
    let chart_data = {};
    let labels = [], series = [], all_series = [];
    sequence.points.forEach(function(point) {
        labels.push(point.agg_distance);
        series.push(point.elevation);
    })
    all_series.push(series);
    chart_data["labels"] = labels;
    chart_data["series"] = all_series;
    return chart_data;
}

document.forms['file-input-form'].elements['my-file'].onchange = function(evt) {
  const files = evt.currentTarget.files;
  Object.keys(files).forEach(i => {
    const file = files[i];
    const reader = new FileReader();
    reader.onload = (evt) => {
        addGpxData(evt.target.result);
    }
    reader.readAsText(file);
  })
};

</script>